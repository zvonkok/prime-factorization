ARIBAS Interpreter for Arithmetic, version 1.50, Aug. 2004
written by 0. Forster, email forster@mathematik.uni-muenchen.de

File aribas.hlp for online help for the command line version of ARIBAS.
This is not a Windows Help File, but a pure ASCII text file.

Under MS-DOS, this file should lie in the same directory as aribas.exe;
under UNIX or LINUX, it must be in a directory which is in the search path

#----------------------------------------------------------------
Date of last change of this help file:
2004-08-09
#----------------------------------------------------------------
?if
?then
?else
?elsif

if <boolean expr> then
        <statement-list>
elsif <boolean expr> then
        <statement-list>
else
        <statement-list>
end;

There may be more (or zero) elsif parts. The else part may also
be absent. Please note the spelling elsif.

SEE ALSO: while
#----------------------------------------------------------------
?while
?do

while <boolean expr> do
        <statement-list>
end;

If <boolean expr> evaluates to true, the statement sequence
<statement-list> is executed (this can change the value of
<boolean expr>). If <boolean expr> is still true, <statement-list>
is again executed. This is repeated until <boolean expr> becomes
false or the while loop is left by a return or a break statement.

SEE ALSO: for, break, continue, return
#----------------------------------------------------------------
?for
?to
?by

for-loop:

for <runvar> := <start> to <end> do
        <statement-list>
end;

for <runvar> := <start> to <end> by <incr> do
        <statement-list>
end;

<runvar> must be an integer variable, <start>, <end> and <incr>
must be integer expressions. Example:

    ==> for k := 9 to 0 by -2 do
            write(k:3);
        end.
      9  7  5  3  1

SEE ALSO: while, break, continue
#----------------------------------------------------------------
?break

break

The command break causes (as in C) the immediate leaving of a
for or a while loop.
Example:

    ==> for x := 10**7+1 to 10**8 by 2 do
            if factor16(x) = 0 then break; end;
        end;
        x.
    -: 10000019

SEE ALSO: while, for, continue, factor16
#----------------------------------------------------------------
?continue

continue

The continue statement works as in C. If within a while or a
for loop the continue statement is encountered, the rest
of the current round of the loop is skipped and execution
continues with the next round of the loop.
Example:

    ==> for i := 1 to 10 do
            write(" #");
            if i = 7 then continue end;
            write(i);
        end.

produces the following output:

 #1 #2 #3 #4 #5 #6 # #8 #9 #10

SEE ALSO: break
#----------------------------------------------------------------
?div
?mod

x div y
x mod y

div and mod are binary, left associative infix operators which may
be applied only to integers and give an integer result.
x div y returns the greatest integer less than or equal to x/y.
The operator mod is defined by the equation

        x = (x div y) * y + (x mod y)

The divisor y must be non-zero.
#----------------------------------------------------------------
?divide

divide(x,y: integer): array[2];

Returns a pair (q,r) of integers such that 
	q = x div y  and  r = x mod y. 
The argument \cc{y} must be non-zero.
Example:

==> divide(100,7).
-: (14, 2)

==> divide(-100,7).
-: (-15, 5)

SEE ALSO: div
#----------------------------------------------------------------
?boolean
?true
?false

boolean

The data type boolean comprises the truth values false and true.
The logical operators not, and, or apply to boolean operands
in the usual way and yield boolean results. Boolean values are
also the result of arithmetic relational operators. In every
place where ARIBAS expects a boolean value (e.g. as conditions
in the if or while constructions), one can also use integer values.
Then the value 0 is considered as false and every nonzero integer
counts as true (this is the same behaviour as in the programming
language C).

SEE ALSO: and, or, not, if
#----------------------------------------------------------------
?not
?and
?or

not, and, or

not is a unary prefix operator, whereas and, or are binary infix
operators. They may be applied to boolean arguments. The evaluation
of the arguments of the binary operators and, or proceeds from left
to right and is stopped as soon as the result is determined.
Thus an expression like

        u > 0 and v/u < 1

is admissible, which would generate an error for u=0 if always both
arguments of the and-operator were evaluated.

SEE ALSO: boolean
#-----------------------------------------------------------------------
?set_printbase

set_printbase(b: integer): integer;

The integer b must be one of the numbers 2, 8, 10, 16. The effect
of this function is that subsequent output of integers is done
in base b representation. Return value is the newly set print base.
(If b is not admissible, the old print base is not altered.)
Example:

    ==> set_printbase(8).
    -: 0o10

    ==> 255.
    -: 0o377

For integers written in bases other than 10, the following prefixes
are used: 0x for base 16, 0o for base 8 and 0y for base 2.

SEE ALSO: get_printbase
#----------------------------------------------------------------
?get_printbase

get_printbase(): integer;

Returns the print base which is currently used.

SEE ALSO: set_printbase
#----------------------------------------------------------------
?max_intsize

max_intsize(): integer;

Returns the maximum number of decimal places of integers
supported by ARIBAS. This number depends on the options
when ARIBAS was compiled and is typically between 20000
and 64000.

SEE ALSO: integer
#----------------------------------------------------------------
?sum
?product

sum(vec: array of integer): integer;
sum(vec: array of real): real;
product(vec: array of integer): integer;
product(vec: array of real): real;

Returns the sum resp. the product of all components of vec.

SEE ALSO: max, min
#----------------------------------------------------------------
?even
?odd

even(x: integer): boolean;
odd(x: integer): boolean;

Tests if x is even resp. odd.
#----------------------------------------------------------------
?max
?min

max(x1,...,xn: integer): integer;
max(x1,...,xn: real): real;
min(x1,...,xn: integer): integer;
min(x1,...,xn: real): real;

Returns the maximum (resp. minimum) of the arguments x1,...,xn.

max(vec: array of integer): integer;
max(vec: array of real): real;
min(vec: array of integer): integer;
min(vec: array of real): real;

Returns the maximum (resp. minimum) of all components of vec.
#----------------------------------------------------------
?abs

abs(x: integer): integer;
abs(x: real): real;

Returns the absolute value of x.
#----------------------------------------------------------
?inc

inc(var x: integer [; delta: integer]): integer;

Increases the integer variable x by delta (by default delta = 1)
und returns the increased value of x. Functionally equivalent to
x := x + delta. The variable parameter x may also be an
array element. Be aware of side effects; constructions like
inc(vec[inc(k)]) may lead to an unexpected result!

SEE ALSO: dec
#----------------------------------------------------------
?dec

dec(var x: integer [; delta: integer]): integer;

Decreases the integer variable x by delta (by default delta = 1)
und returns the decreased value of x. Functionally equivalent to
x := x - delta. The variable parameter x may also be an
array element. Be aware of side effects; constructions like
dec(vec[dec(k)]) may lead to an unexpected result!


SEE ALSO: inc
#----------------------------------------------------------
?gcd

gcd(x1,...,xn: integer): integer;

Returns the greatest common divisor of the integers x1,x2,...,xn.
For n = 1, one has gcd(x) = abs(x); if n = 0, then gcd() = 0.

gcd(vec: array of integer): integer;

Returns the greatest common divisor of all components of vec.

SEE ALSO: gcdx
#----------------------------------------------------------
?gcdx

gcdx(x,y: integer; var u,v: integer): integer;

Returns the greatest common divisor d of x, y.
At the same time, the variables u and v are set to values
such that
        d = u*x + v*y
Example:

    ==> gcdx(7,12,u,v).
    -: 1

    ==> (u,v).
    -: (7, -4)

SEE ALSO: gcd, mod_inverse
#----------------------------------------------------------
?mod_inverse

mod_inverse(x, mm: integer): integer;

If x and mm are reatively prime, this function returns the inverse
of x modulo mm. Otherwise the return value is 0. Examples:

    ==> mod_inverse(3,17).
    -: 6

    ==> mod_inverse(3,18).
    -: 0

SEE ALSO: gcdx
#--------------------------------------------------------------
?isqrt

isqrt(x: integer): integer;

x must be a non-negative integer. Returns the greatest integer
y such that y*y <= x.

SEE ALSO: sqrt, gfp_sqrt
#-------------------------------------------------------------
?gfp_sqrt

gfp_sqrt(p,x: integer): integer;

p must be an odd prime and x an integer which is a square modulo p, 
i.e. jacobi(x,p) /= -1. The function returns a square root of 
x modulo p, that is, a square root in the field GF(p).
Example:

    ==> p := next_prime(10**6). 
    -: 1000003 
 
    ==> x := 10. 
    -: 10 
 
    ==> jacobi(x,p). 
    -: 1 
 
    ==> y := gfp_sqrt(p,x). 
    -: 394215 
 
    ==> y**2 mod p. 
    -: 10 

SEE ALSO: isqrt
#-------------------------------------------------------------
?factorial

factorial(n: integer): integer;

n must be a non-negative integer. Returns the factorial of n,
(usually denoted by n!). Example:

    ==> factorial(8).
    -: 40320
#-------------------------------------------------------------
?mod_coshmult

mod_coshmult(x,s,mm: integer): integer;

If x is an integer and xi a number such that cosh(xi) = x,
then cosh(s*xi) is an integer for all natural numbers s.
The function returns this number modulo mm.
The result can be obtained by the following recursively
defined (Lucas) sequence:
        a(0) := 1;
        a(1) := x;
        a(k+2) := 2*x*a(k+1) - a(k);
The result is the number a(s) mod mm.
This function is useful to implement the (p+1)-factorization method.

SEE ALSO: mod_pemult
#-------------------------------------------------------------
?mod_pemult

mod_pemult(x,s,a,mm: integer): array[2] of integer;

Let pe be the Weierstrass pe-function on the elliptic curve E(a)
        y*y = x*x*x + a*x*x + x
and let xi be a point on the curve with pe(xi) = x. Then s*xi is
a point of E(a) (with respect to the abelian group structure on the
elliptic curve). If s*xi is not a pole of pe, then pe(s*xi) = u/v
is a rational number. (We may suppose that u and v are relatively
prime.) If v is relatively prime to mm, the function 
mod_pemult(x,s,a,mm) returns (z,1), where z is an integer
satisfying z*v = u mod mm (i.e. we have z = u/v in Z/mmZ).
If v and mm have a greatest common divisor d > 1, the function
returns (d,0). If s*xi is a pole of pe, the return value is (mm,0).
This function is useful for the factorization with elliptic curves.

SEE ALSO: mod_coshmult
#---------------------------------------------------------------
?factor16

factor16(x [,x0 [,x1]]: integer): integer;

factor16(x) seeks a prime divisor p of x with p < min(2**16,x).
If such a prime divisor exists, the smallest one is returned.
Otherwise the function returns 0. If the optional arguments x0
resp. x0 and x1 are supplied, only prime divisors p satisfying the
additional conditions p >= x0 resp. x0 <= p <= x1 are considered.
Examples:

    ==> factor16(2**32 + 1).
    -: 641

    ==> factor16(2**32 + 1, 642).
    -: 0

SEE ALSO: prime32test, rho_factorize
#-------------------------------------------------------------
?prime32test

prime32test(x: integer): integer;

Tests if abs(x) is a prime number < 2**32.
If this is true, the function returns 1.
If abs(x) < 2**32, but is not prime, 0 is returned.
For abs(x) >= 2**32, the function returns -1.

SEE ALSO: rab_primetest, factor16
#------------------------------------------------------------
?rab_primetest

rab_primetest(x: integer): boolean;

Performs the Rabin probabilistic prime test. If the function
returns false, the number is certainly composite. A 'random '
number x, for which factor16(x) = 0 and rab_primetest(x) = true
is prime with high probability. An exception are numbers constructed
purposely to fool the Rabin prime test. But also for these
numbers the error probability is less than 1/4.
To decrease the error probability, one can repeat the test
several times.

SEE ALSO: prime32test, factor16
#----------------------------------------------------------
?jacobi

jacobi(a,m: integer): integer;

Returns the Jacobi symbol of a over m. The module m must be
an odd integer; a may be an arbitrary integer, the result depends
only on the residue class of a modulo m. If a and m are not
relatively prime, the return value is 0, otherwise it is
1 or -1. If p is an odd prime and a not a multiple of p, then
jacobi(a,p) = 1 if and only if a is a quadratic residue modulo p.
#------------------------------------------------------------
?rho_factorize

rho_factorize(x:integer [; b: integer]): integer;

Tries to factorize x using Pollard's rho-algorithm. The optional
argument b is a bound for the maximal number of steps (default
value b = 2**16). If the algorithm finds a factor, it is returned,
in case of failure the return value is 0. The number x should
be free of small prime factors (e.g. < 1000). Then, if x has
a prime factor p < sqrt(x), the algorithm will in general find
a factorization of x if b is a small multiple of sqrt(p).
If the return value y is > 1 and < x, it is certainly a factor
of x, but not necessarily prime.

rho_factorize(x,0).
rho_factorize(x,b,0).

Silent version. With last argument 0, all messages to the screen are
suppressed.

SEE ALSO: cf_factorize, qs_factorize, factor16
#----------------------------------------------------------------
?cf_factorize

cf_factorize(x: integer [; mm: integer]): integer;

Tries to factorize x using the Morrison-Brillhart continued
fraction factorization algorithm. The run time does not depend
on the size of the prime factors of x. (Hence, if it is known
that x has small prime factors, another factorization method
like rho_factorize should be used.) 
If the period of the continued fraction of sqrt(x) is too short, 
the factorization will fail. In this case one should supply a 
second argument, which must be an integer mm with 1 <= mm < 1024. 
Then the continued fraction expansion of sqrt(mm*x) will be used.

cf_factorize(x,0).
cf_factorize(x,mm,0).

Silent version. With last argument 0, all messages to the screen are
suppressed.

SEE ALSO: rho_factorize, qs_factorize
#----------------------------------------------------------------
?qs_factorize

qs_factorize(x: integer): integer;

Tries to factorize x using the multiple polynomial quadratic 
sieve factorization algorithm. The run time does not depend
on the size of the prime factors of x. (Hence, if it is known
that x has small prime factors, another factorization method
like rho_factorize should be used.)

qs_factorize(x,0).

Silent version. With second argument 0, all messages to the screen are
suppressed.

SEE ALSO: rho_factorize, cf_factorize, ec_factorize
#-------------------------------------------------------------------
?ec_factorize

ec_factorize(x: integer[; m: integer]): integer;

Tries to factorize x by the elliptic curve method. The optional 
argument m is a bound for the number of elliptic curves used. 
If the algorithm finds a factor, it is returned, in case of 
failure the return value is 0.  If the return value y is > 1, 
it is certainly a factor of x, but not necessarily prime.

ec_factorize(x: integer; pbounds: array[2] [; m: integer]): integer;

You may explicitely prescribe the prime bound and the bigprime bound 
by the second argument in form of a 2-dimensional vector  
pbounds = (bound1,bound2). The constant bound1 must be < 2**16 
and bound2 < 2**24. The third optional argument m is the maximal 
number of elliptic curves used.

SEE ALSO: qs_factorize
#-------------------------------------------------------------------
?next_prime

next_prime(x: integer): integer;

Returns the smallest prime p >= x. If x > 2**32, p is only a prime
with high probability, since the probabilistic Rabin primality test
is used. The number returned has no prime factor < 2**16 and has
passed the strong pseudo prime test with ten random bases.

next_prime(x,0).

Silent version. With second argument 0, all messages to the screen are
suppressed.

SEE also: rab_primetest
#-------------------------------------------------------------------
?bit_test

bit_test(x,n: integer): integer;

Returns 1, if the bit in position n of x is set, otherwise returns 0.
Negative integers are thought to be in two's complement
representation, where the sign bit extends to infinity at the
left hand side. For example, the bit pattern of the two's complement
representation of -1 is

      ......11111111111111111111111111111111

The count of positions begins with 0 (the bit i position n has
weigth 2**n).
For example, bit_test(x,0) = 1 if and only if x is odd.

SEE ALSO: bit_set, bit_clear
#----------------------------------------------------------------
?bit_set

bit_set(x,n: integer): integer;

Sets the bit in position n of the integer x equal to 1 and returns
the modified integer. Example:

    ==> bit_set(16,2).
    -: 20

SEE ALSO: bit_test, bit_clear
#----------------------------------------------------------------
?bit_clear

bit_clear(x,n: integer): integer;

Clears the bit in position n of the integer x (i.e. sets it equal
to 0) and returns the modified integer. Examples:

    ==> bit_clear(20,2).
    -: 16

    ==> bit_clear(-1,0).
    -: -2

SEE ALSO: bit_test, bit_set
#----------------------------------------------------------------
?bit_shift

bit_shift(x,n: integer): integer;

The number n may be positive, negative or zero. If n >= 0,
bit_shift(x,n) is a shift of the bit representation of x of
n positions to the left (i.e. in direction of more significant
bits); this is equivalent to a multiplication by 2**n.
If n < 0, this is a shift of abs(n) positions to the right
(i.e. in direction of less significant bits); equivalent to
x div 2**abs(n). Examples:

    ==> bit_shift(-7,3).
    -: -56

    ==> bit_shift(-7,-1).
    -: -4

    ==> bit_shift(-7,-100).
    -: -1

SEE ALSO: bit_test
#----------------------------------------------------------------
?bit_not

bit_not(x: integer): integer;

Inverts all bits of x. Equivalent to -x-1.

SEE ALSO: bit_test, bit_and
#----------------------------------------------------------------
?bit_and
?bit_or
?bit_xor

bit_and(x,y: integer): integer;
bit_or(x,y: integer): integer;
bit_xor(x,y: integer): integer;

Bitwise and, or resp. exclusive or of x and y.
For example, bit_and(x,3) is equivalent to x mod 4.

SEE ALSO: bit_not, bit_test
#----------------------------------------------------------------
?bit_length

bit_length(x: integer): integer;

Returns the smallest natural number n such that abs(x) < 2**n

SEE ALSO: bit_count, bit_test
#----------------------------------------------------------------
?bit_count

bit_count(x: integer): integer;

Returns the number of bits equal to 1 in the binary 
representation of abs(x). Examples:

==> bit_count(0).
-: 0

==> bit_count(255).
-: 8

==> x := 10001.
-: 10001

==> write(x:base(2)).
100111_00010001
-: 1

==> bit_count(x).
-: 6

==> bit_count(-x).
-: 6

SEE ALSO: bit_test, bit_length
#----------------------------------------------------------------
?pi

constant pi

    ==> pi.
    -: 3.14159265

Internally, pi is stored with a precision equal to max_floatprec().

    ==> set_floatprec(long_float).
    -: 128

    ==> pi.
    -: 3.14159_26535_89793_23846_26433_83279_50288_4

SEE ALSO: arctan2, set_floatprec, max_floatprec
#----------------------------------------------------------------
?real

real

The data type real comprises a computer approximation of the real
numbers. Real literals are given in decimal representation, beginning
with an optional sign + or -, then a non-empty sequence of decimal
digits, an obligatory decimal point, a second non-empty sequence
of decimal digits and an optional scaling factor, consisting of
the symbol E (or e), an optional sign and a non-empty sequence of
decimal digits. Examples:
        0.3
        +3.1e-45
        -0.00007E1000
The following forms are not admissible real literals:
        .333
        333e-3.
(The number which is meant by these symbols may be represented by
0.333 or 333.0e-3).

SEE ALSO: set_floatprec, get_floatprec, decode_float, float
#----------------------------------------------------------------
?floor

floor(x: real): integer;

Returns the greatest integer n <= x. Examples:

    ==> floor(pi).
    -: 3

    ==> floor(-pi).
    -: -4

SEE ALSO: trunc, round
#----------------------------------------------------------------
?trunc

trunc(x: real): integer;

If x >= 0, equivalent to floor(x).
For x < 0, trunc(x) = -trunc(-x).
Examples:

    ==> trunc(pi).
    -: 3

    ==> trunc(-pi).
    -: -3

SEE ALSO: floor, round, frac
#----------------------------------------------------------------
?frac

frac(x: real): real;

Defined by the equation

        x = trunc(x) + frac(x)

Examples:

    ==> frac(1.23).
    -: 0.230000000

    ==> frac(-1.23).
    -: -0.230000000

SEE ALSO: trunc
#----------------------------------------------------------------
?round

round(x: real): integer;

Rounds x to the next integer n. If x has exactly the distance 1/2
from two integers, rounds to the even integer. Examples:

    ==> round(pi).
    -: 3

    ==> round(3.5).
    -: 4

    ==> round(2.5).
    -: 2

SEE ALSO: floor, trunc
#----------------------------------------------------------------
?set_floatprec
?single_float
?double_float
?long_float

set_floatprec(bb: integer): integer;
set_floatprec(Floattype): integer;

This function serves to set the precision (in bits) which is used for 
subsequent calculations with reals. By default, a precision of 32 bits 
is used (corresponding to 9-10 decimal places), but it can be set to 
several higher values up to an implementation dependent limit, which 
can be determined by the function max_floatprec(). The argument of 
set_floatprec is either an integer bb,  indicating the number of bits. 
If necessary, bb is rounded to the next higher available precision. 
The argument can also be a symbol Floattype, for which the following 
choice is available:
        single_float:    32 bits
        double_float:    64 bits
        long_float:     128 bits
The function returns the new float precision. Example:

    ==> set_floatprec(long_float);
        x := sqrt(2).
    -: 1.41421356237309504880168872420969808

SEE ALSO: get_floatprec, max_floatprec
#----------------------------------------------------------------
?get_floatprec

get_floatprec(): integer;
get_floatprec(x: real): integer;

In the first form (without arguments), the function returns the current 
float precision (in bits, i.e. one of the numbers 17, 32, 64, 128, 192). 
The default float precision of ARIBAS is 32 bits.
If the argument is a real number x, the precision of x is returned.
Examples:

    ==> set_floatprec(200).
    -: 256

    ==> get_floatprec(pi).
    -: 4096

    ==> get_floatprec(1/3).
    -: 256

SEE ALSO: set_floatprec, decode_float
#----------------------------------------------------------------
?max_floatprec

max_floatprec(): integer;

This function returns the maximum floating point precision (in bits) 
which is available in the current implementation of ARIBAS.
Example:

==> max_floatprec().
-: 4096

SEE ALSO: set_floatprec, get_floatprec
#----------------------------------------------------------------
?decode_float

decode_float(x: real): array[2] of integer;

For a real number x, the function decode_float(x) returns
a pair (mant, expo) of integers, reflecting the internal
representation of x. The following equation holds:
                x = mant * 2**expo
Example:

    ==> set_printbase(16).
    -: 0x10

    ==> decode_float(-1/3).
    -: (-0xAAAA_AAAA, -0x21)

SEE ALSO: get_floatprec, set_printbase, float
#----------------------------------------------------------------
?float

float(x: integer [; Floattype]): real;
float(x: real [; Floattype]): real;

Floattype must be one of the symbols single_float, double_float, 
long_float or an integer bb indicating the float precision in bits.
If this argument is not given, the current float precision is assumed.
The function transforms the number x to data type real with
float precision Floattype.

Example: Suppose that the current float precision is single_float.

    ==> float(5).
    -: 5.00000000

SEE ALSO: set_floatprec, decode_float
#----------------------------------------------------------------
?sqrt
?exp
?log
?sin
?cos
?tan
?arctan
?arcsin
?arccos

sqrt(x: real): real;
exp(x: real): real;
log(x: real): real;
sin(x: real): real;
cos(x: real): real;
tan(x: real): real;
arctan(x: real): real;
arcsin(x: real): real;
arccos(x: real): real;

The functions sqrt (square root), exp, log (natural logarithm),
sin, cos, tan, arctan, arcsin, arccos all expect one real argument
and return a real. If the argument is an integer, it is automatically
transformed to a real. Example:

    ==> log(2).
    -: 0.693147180

SEE ALSO: arctan2, set_floatprec, pi, isqrt
#----------------------------------------------------------------
?arctan2

arctan2(y,x: real): real;

The two numbers x,y may not be simultaneously 0. The function
returns an angle phi with -pi < phi <= pi, satisfying
        x = r * cos(phi);
        y = r * sin(phi);
where r = sqrt(x*x + y*y).
If x > 0, then arctan2(y,x) = arctan(y/x).

    ==> arctan2(0,-1).
    -: 3.14159265

SEE ALSO: arctan, pi
#----------------------------------------------------------------
?random

random(x: integer): integer;
random(x: real): real;

Returns an integer (resp. real) pseudo random number z with 0 <= z < x.

SEE ALSO: random_seed
#----------------------------------------------------------
?random_seed

random_seed([s: integer]): integer;

random_seed without an argument returns the present state of the
random generator (which is an integer z with 2**48 <= z < 2**49).

With an integer argument s, the state of the random generator is
set to a value z such that z = s mod 2**48 and 2**48 <= z < 2**49.
In this way one can generate reproducible values of the random
function (for test purposes).

SEE ALSO: random
#----------------------------------------------------------
?char

char

The data type char comprises 256 characters with code numbers 0
to 255. Characters with code numbers < 128 are the standard ASCII
characters (they comprise printable characters and control characters);
characters with code number >= 128 are system dependent. Character
literals of printable characters are given by enclosing the symbol
between single quotes, as in 'A'. The function chr transforms integer
values from 0 to 255 into the corresponding characters. In this way,
also the non-printable characters can be generated. For example,
chr(7) is the bell character (which usually generates a beep when
output to the terminal).

SEE ALSO: chr, ord, string
#----------------------------------------------------------
?chr
?ord

chr(n: integer): char;
ord(ch: char): integer;

The function chr generates the character with ASCII-Code n (0 <= n < 256),
ord is the inverse function of chr. Examples:

    ==> chr(63).
    -: '?'

    ==> ord('?').
    -: 63

SEE ALSO: char
#----------------------------------------------------------*)
?concat

concat(arg0, arg1, ... , argn): string;

The function concat expects one or more arguments which must be
strings or characters. The result is a string which is the
concatenation of all arguments. Example:

    ==> concat("string",'_',"split").
    -: "string_split"

Using concat, one can construct strings with embedded double quotes:

    ==> concat("123",'"',"456").
    -: "123"456"

SEE ALSO: string_split
#------------------------------------------------------------
?toupper

toupper(str: string): string;
toupper(ch: character): character;

Transforms a string resp. a character to upper case. Only characters
between 'a' and 'z' are affected. All others remain untouched.
Example:

    ==> toupper("Zapp-up!").
    -: "ZAPP-UP!"

SEE ALSO: tolower
#-------------------------------------------------------------
?tolower

tolower(str: string): string;
tolower(ch: character): character;

Transforms a string resp. a character to lower case. Only
characters between 'A' and 'Z' are affected. All others remain
untouched. Examples:

    ==> tolower("ABCdef123").
    -: "abcdef123"

    ==> tolower('Z').
    -: 'z'

SEE ALSO: toupper
#----------------------------------------------------------
?string_split

string_split(str: string [; sep: string]): array of string;

Splits the string str into one or more parts and returns a vector
whose components are these parts. The splitting considers as separators
the characters contained in the string sep. If the argument sep is not 
supplied, SPACE, TAB, CR and NEWLINE are used by default.
Examples;

    ==> string_split("abc def").
    -: ("abc", "def")

    ==> string_split("abc def;xxx=yyy",";= ").
    -: ("abc", "def", "xxx", "yyy")

SEE ALSO: concat
#----------------------------------------------------------
?substr_index

substr_index(str, str1: string): integer;

Searches for an occurrence of str1 as a substring of str
and returns the position (the count begins with 0). If
str1 does not occur as a substring of str, -1 is returned.
Examples:

    ==> substr_index("string_split","split").
    -: 7

    ==> substr_index("string_split","Split").
    -: -1

SEE ALSO: string_scan
#----------------------------------------------------------
?string_scan

string_scan(str, set: string [; mode: boolean]): integer;

When mode=true (default), searches for the first occurrence of
a character from the string set in the string str and returns
its position. If no character from set occurs in str, -1 is
returned. Example:

==> str := "vec := (1,2,3)".
-: "vec := (1,2,3)"

==> string_scan(str,"+-()").
-: 7

==> string_scan(str,"+-[]").
-: -1

If mode=false, then the function searches for the first character 
in str, that does not belong to set. If all characters of str occur in
set, then -1 is returned. For example,

	string_scan(str,"0123456789",false) = -1

is true if and only if the string str consists entirely
of digits.

SEE ALSO: substr_index
#----------------------------------------------------------
?itoa

itoa(x: integer [; base: integer]): string;

The integer x is converted to a string, giving the textual
representation of this integer. The second optional argument
is the base to be used, which may have one of the values 2,8,10,16.
By default, base 10 is used. Example:

    ==> itoa(1234).
    -: "1234"

    ==> itoa(1234,16).
    -: "4D2"

SEE ALSO: atoi, ftoa
#------------------------------------------------------------
?ftoa

ftoa(x: real): string;

The real number x is converted to a string.
Examples:

    ==> ftoa(1/239).
    -: "0.00418410042"

    ==> ftoa(pi*10**100).
    -: "3.14159265E100"

SEE ALSO: float_ecvt, itoa
#----------------------------------------------------------
?atoi

atoi(s: string [; var len: integer]): integer;

A string s, representing an integer, is transformed to this integer.
The function may be called with an optional second variable argument
len. The function stores in len an integer, which in general is the length
of the string s. If len < length(s), then only the substring containing
the first len characters of s is an admissible representation of an integer.
In particular len=0 indicates a non-admissible string. Examples:

    ==> atoi("1234").
    -: 1234

    ==> atoi("0xFF 1234",len).
    -: 255

    ==> len.
    -: 4

SEE ALSO: itoa, atof
#----------------------------------------------------------
?atof

atof(s: string [; var len: integer]): real;

A string s, representing a real number, is transformed to this real.
The function may be called with an optional second variable argument
len. The function stores in len an integer, which in general is the length
of the string s. If len < length(s), then only the substring containing
the first len characters of s is an admissible representation of a real.
In particular len=0 indicates a non-admissible string.

SEE ALSO: ftoa, atoi
#----------------------------------------------------------
?float_ecvt

float_ecvt(x: real; ndig: integer; var decpos, sign: integer): string;

The real x is transformed to a string of length ndig. The string contains 
only digits. The position of the decimal point is returned in the 
variable paramenter decpos (decpos < 0 means that the decimal point is 
to the left of the beginning of the string). The sign of x is returned 
in the variable parameter sign (sign = 0 means x >= 0, sign /= 0
means x < 0). float_ecvt is analogous to the UNIX C-function ecvt.
Example:

    ==> float_ecvt(pi,10,decpos,sign).
    -: "3141592654"

    ==> decpos.
    -: 1

    ==> sign.
    -: 0

SEE ALSO: ftoa
#-------------------------------------------------------------
?md5

md5(str: string): byte_string;
md5(str: byte_string): byte_string;

Calculates the md5 fingerprint of the string (resp. byte_string) str.
Example:

    ==> md5("1234567890").
    -: $E807_F1FC_F82D_132F_9BB0_18CA_6738_A19F
 
#-------------------------------------------------------------
?cardinal

cardinal(b: byte_string): integer;

Transforms a byte_string into a non-negative integer. The components of 
the byte_string are considered as the digits of an integer with respect 
to base 256. The leftmost byte corresponds to the least significant digit. 
Therefore the function returns the integer

        sum(b[i] * 256**i: 0 <= i < length(b)).

Example:

    ==> cardinal($000A).
    -: 2560

SEE ALSO: integer, byte_string
#----------------------------------------------------------
?integer

integer

default data type of ARIBAS
ARIBAS can handle integers of up to 20000 decimal digits.

(*--------------------------------------------------------*)
integer(b: byte_string): integer;

Transforms a byte_string into an integer. The components
of the byte_string are considered as the digits of an integer
with respect to base 256 in two's complement representation.
If len := length(b) and the most significant bit of b[len-1] is not
set, then integer(b) = cardinal(b). But if the most significant bit
of b[len-1] is set, then

        integer(b) = cardinal(b) - 256**len.

SEE ALSO: cardinal, byte_string
#-----------------------------------------------------------------------
?gf2nint

gf2nint

Data type of elements of the fields GF(2**n) of characteristic 2. 
To be able to do arithmetic in GF(2**n), the field must be initialized 
by the command gf2n_init(n). The elements of GF(2**n) are represented 
by polynomials of degree < n with coefficients 0 or 1, i.e. by bitvectors
of length <= n. Literals of data type gf2nint are marked by the 
prefix 2x, followed by the hexadecimal representation of this
bitvector. For example, in the field GF(2**8), the element
2x8A represents the class of the polynomial
    X**7 + X**3 + X,
since 2**7 + 2**3 + 2 = 138 = 0x8A = 0y10001010. Also binary and octal
representations are admissible; these are marked with the
prefixes 2y and 2o respectively. For example,
    2x8A = 2y10001010 = 2o212.
Elements of data type gf2nint can be added, mulitiplied, divided and
raised to integer powers: x + y, x*y, x/y, x**n.

gf2nint(x: integer): gf2nint;

Converts an integer to an element of data type gf2nint. Inverse
function is integer(x: gf2nint): integer;

SEE ALSO: gf2n_init, gf2n_fieldpol, gf2n_degree, gf2n_trace
#----------------------------------------------------------
?gf2n_init

gf2n_init(deg: integer): integer;

Initializes the field GF(2**deg), which is an extension of degree deg 
of the field with two elements GF(2). Return value is an integer f, 
representing an irreducible polynomial of degree deg. If the integer f 
in binary representation is
    f = sum(a_i * 2**i, i=0,1,...,deg), a_i = 0,1,
then the corresponding polynomial f(X) in GF(2)[X] is
    f(X) = sum(a_i * X**i, i=0,1,...,deg).
The field GF(2**deg) is constructed as GF(2)[X]/(f(X)). Example:

    ==> gf2n_init(53).
    -: 9_00719_92547_41063

    ==> write(_:base(2)).
    100000_00000000_00000000_00000000_00000000_00000000_01000111
    -: 1

In this case the irreducible polynomial serving to construct
the field GF(2**53) is
    f(X) = X**53 + X**6 + X**2 + X + 1.

SEE ALSO: gf2nint, gf2n_fieldpol, gf2n_degree, max_gf2nsize, gf2n_trace
#-----------------------------------------------------------------------
?gf2n_fieldpol

gf2n_fieldpol(): integer;

Returns the irreducible polynomial defining the field GF(2**n)
which is active at present. The polynomial is represented
by an integer; see description of the function gf2n_init().

SEE ALSO: gf2n_init, gf2n_degree, gf2nint 
#-----------------------------------------------------------------------
?gf2n_degree

gf2n_degree(): integer;

Returns the degree of the field GF(2**n) which is currently active.

SEE ALSO: gf2n_init, gf2nint
#-----------------------------------------------------------------------
?gf2n_trace

gf2n_trace(z: gf2nint): integer;

Returns the trace 0 or 1 of an element z in GF(2**n).
The trace of z is 0 if and only if the quadratic equation
x**2 + x = z has a solution x in GF(2**n).

SEE ALSO:  gf2n_init, gf2nint
#-----------------------------------------------------------------------
?max_gf2nsize

max_gf2nsize(): integer;

Returns the maximal degree of a field GF(2**n) supported by the
current version of ARIBAS.

SEE ALSO:  gf2n_init, gf2n_degree, gf2nint
#-----------------------------------------------------------------------
?byte_string

A byte_string is a finite sequence of bytes. Byte_string literals
are written in the form $XXXXXX...XX, where XX stands for the
hexadecimal representation of a byte.
(*--------------------------------------------------------------------*)
byte_string(x: integer [; len: integer]): byte_string;

byte_string(x) transforms an integer x into a byte_string of length len
(default = byte_length(x)). It is the inverse function of
integer(bb: byte_string). If a second argument len is given and
len < byte_length(x), then the byte_string is truncated and only the len
least significant bytes are retained. If len > byte_length(x), bytes of
value 0 (if x >= 0) resp. 0xFF (if x < 0) are added. Example:
    ==> byte_string(-1,4).
    -: 0xFFFF_FFFF
(*--------------------------------------------------------------------*)
byte_string(s: string): byte_string;

Transforms an ordinary (text) string into a byte_string. The components
of the resulting byte_string are the ASCII codes of the characters of s.

SEE ALSO: integer, string
#----------------------------------------------------------
?string

string

The data type string comprises sequences of characters and serves
to represent text. String literals are given by enclosing the
character sequence between double quotes, as in "ABCD". Strings
containing double quotes can be constructed using concat.
One can access a single character of a string in the following way:

    ==> s := "abcdef";
        s[3].
    -: 'd'

(*---------------------------------------------------------*)
string(b: byte_string): string;

Transforms a byte_string into a text string; inverse function
of byte_string. Be careful if some components of the byte_string
b are codes of non-printable control characters.

SEE ALSO: byte_string, char, concat
#-------------------------------------------------------------
?mem_btest

mem_btest(var b: byte_string; n: integer): integer;

Returns the value 1 or 0 of the bit at position n in the
byte_string b (position is zero based).

SEE ALSO: mem_bset, mem_bclear
#----------------------------------------------------------
?mem_bset

mem_bset(var b: byte_string; n: integer): byte_string;

Sets the bit at position n in the byte_string b to 1
and returns the modified byte_string.

SEE ALSO: mem_bclear, mem_btest
#----------------------------------------------------------
?mem_bclear

mem_bclear(var b: byte_string; n: integer): byte_string;

Clears the bit at position n in the byte_string b (i.e. sets it to 0)
and returns the modified byte_string.

SEE ALSO: mem_bset, mem_btest, mem_not
#----------------------------------------------------------
?mem_not

mem_not(var b: byte_string): byte_string;

Inverts all bits in the byte_string b and returns the
modified byte_string.

SEE ALSO: mem_xor
#----------------------------------------------------------
?mem_or
?mem_and
?mem_xor

mem_and(var b1,b2: byte_string): byte_string;
mem_or(var b1,b2: byte_string): byte_string;
mem_xor(var b1,b2: byte_string): byte_string;

The first byte_string argument b1 is replaced by the bitwise
and (resp. or, xor) of b1 and b2. The modified byte_string b1
is returned.

SEE ALSO: mem_not, mem_shift, mem_btest
#----------------------------------------------------------
?mem_shift

mem_shift(var b: byte_string; n: integer): byte_string;

Performs a bit shift by abs(n) binary digits. If n > 0, the direction
is from least-significant to most-significant, for n < 0, the shift
is in the opposite direction. n bits are lost. They are replaced
by 0's. Example:

    ==> bb := $ABCD;
        mem_shift(bb,4).
    -: $B0DA

    ==> mem_shift(bb,4).
    -: $00AB

SEE ALSO: mem_not, mem_xor
#----------------------------------------------------------
?mem_bitswap

mem_bitswap(var b: byte_string): byte_string;

Within each byte of b, the 8 bits are swapped from most significant
<--> least significant, that is, sum{b_k*2**k, 0 <= k < 8}
is replaced by sum{b_k*2**(7-k), 0 <= k < 8}.
The modified byte_string is returned. Example:

    ==> bb := $0102_1e2f.
    -: $0102_1E2F

    ==> mem_bitswap(bb).
    -: $8040_78F4

SEE ALSO: mem_byteswap, mem_btest
#----------------------------------------------------------
?mem_byteswap

mem_byteswap(var b: byte_string; wordlen: integer): byte_string;

The byte_string is subdivided in groups of wordlen bytes each.
Within each group, the bytes are swapped from most significant
<--> least significant.
The modified byte_string is returned.

Example:
    ==> bb := $AABBCCDDEE.
    -: $AABB_CCDD_EE

    ==> mem_byteswap(bb,2).
    -: $BBAA_DDCC_EE

SEE ALSO: mem_bitswap, mem_shift
#---------------------------------------------------------------
?array
?of

array of Type

The array is a structured data type, consisting of finite sequences
of components of a given (but arbitrary) data type Type. Array literals
are given by a comma separated list of its components. The list is
enclosed between a pair of parentheses ( and ), for example
        vec := (37, 41, -9).
However, for arrays of length 1, braces must be used.
        vec1 := {37}.
The expression (37) is interpreted by ARIBAS as the number 37.
One may use braces instead of parentheses also for arrays of length > 1.
The components of an array vec can be accessed as
        vec[i]
where 0 <= i < length(vec).

SEE ALSO: subarray, vector_ops, alloc, max_arraysize
#---------------------------------------------------------------
?subarray

Besides accessing single components of an array, one can also access
whole subarrays. If vec is an array, then
        vec[n1..n2]
denotes the subarray consisting of all components vec[i]
with n1 <= i <= n2. Example:

    ==> vec := (1,2,3,4,5,6,7,8,9,10).
    -: (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    ==> vec[2..6].
    -: (3, 4, 5, 6, 7)

The upper bound may be omitted:
vec[n1..] is equivalent to vec[n1..length(vec)-1].

Subarrays may also appear at the left hand side of assignments
and thus allow the simultaneous modification of several components.

SEE ALSO: array
#---------------------------------------------------------------
?vector_ops

-vec, vec1 + vec2, vec1 - vec2
lambda * vec, vec * lambda, vec/lambda

vec, vec1, vec2 may be of data type array of integer or array of real
and lambda of data type integer or real. Calculate the negative of vec,
sum and difference of vectors vec1 and vec2, resp. the product of
the vector vec by the scalar lambda or 1/lambda. vec1 and vec2 need not 
have the same length; the shorter one is implicitely expanded to the
greater length by appending zeroes. Examples:

==> -(1,1) + pi*(1,2,3).
-: (2.14159265, 5.28318531, 9.42477796)

==> (100, 200, 300, 400)/1.95583.
-: (51.1291881, 102.258376, 153.387564, 204.516752)

vec div N, vec mod N

Here vec must be an array of integers and N an integer /= 0. The operators 
div resp. mod are applied componentwise to the vector vec. Example:

==> (1000, 1100, 1200) mod 12.
-: (4, 8, 0)

SEE ALSO: sum, product, gcd, max, min
#---------------------------------------------------------------
?max_arraysize

max_arraysize(): integer;

In the present version of ARIBAS, lengths of arrays cannot be
very large. The function max_arraysize returns the maximal
admissible length. Typically, under UNIX, this value is about 64000,
under MSDOS about 12000 or 16000.
The maximal admissible length for strings and byte_strings is

        min(4*max_arraysize(), 2**16-1).

SEE ALSO: array, alloc
#---------------------------------------------------------------
?sort

sort(var vec: array of integer): array of integer;
sort(var vec: array of real): array of real;
sort(var vec: array of string): array of string;

The array vec, which is passed to the function sort as a variable
argument, is sorted in non-decreasing order (for strings, the
lexicographic order with respect to the ASCII-codes of characters
is used). The sorted array is returned.

sort(var vec: array of Type; compfun: function): array of Type;

The function sort may be given as a second optional argument
a comparison function
        compfun(x,y: Type): integer;
which must be a function of two arguments of the same data type
as the components of the array. The relation defined by
compfun(x,y) <= 0 must be transitive. Then vec is sorted in
non-decreasing order, where x <= y is defined by compfun(x,y) <= 0.

SEE ALSO: binsearch
#---------------------------------------------------------------
?binsearch

binsearch(ele: <type>; var vec: array of <type> 
          [; compfun: function]): integer;

The array vec must be a sorted array of elements of type <type>.
The function searches in this array for an occurrence of the
element ele and returns its position (zero-based). If ele is not
found, -1 is returned.
The third argument of binsearch is a comparison function

        compfun(x,y: <type>): integer;

which must be a function of two arguments of the same data type
as the components of the array (see function sort).
If vec is an array of integers, characters or strings,
then the comparison function may be omitted. In this case the 
natural order (numerical resp. alphabetical) is assumed.

SEE ALSO: sort
#---------------------------------------------------------------
?alloc

alloc(Arraytype, Len [,Ele]): Arraytype;

Arraytype must be one of the symbols array, string, byte_string.
The function generates an array (resp. a string, a byte_string)
of length Len, where all components are equal to Ele. If the argument
Ele is not given, a default element is used. This default element
is 0 for arrays, the space character ' ' for strings, and the
zero byte for byte_strings.
Examples:

    ==> alloc(array,10).
    -: (0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

    ==> alloc(string,5,'A').
    -: "AAAAA"

    ==> alloc(byte_string,5,127).
    -: $7F7F_7F7F_7F
#----------------------------------------------------------
?realloc

realloc(var vec: <arraytype>; len: integer [; ele]): <arraytype>

The variable argument vec must be an array, a string or a byte_string. 
If the integer len is bigger than the length of vec, the function 
increases the length of vec to len by appending components of value ele 
at the end. If ele is not given, default values are used. The new
array (resp. string}, byte_string) is returned and also placed in the 
variable vec. If len is equal to the length of vec, then vec remains 
unchanged. If len is smaller than the length of vec, then vec is 
truncated to this smaller length. Examples:

==> vec := (17,4,31).
-: (17, 4, 31)

==> realloc(vec,5,53).
-: (17, 4, 31, 53, 53)

==> bb := $AABB.
-: $AABB

==> realloc(bb,10).
-: $AABB_0000_0000_0000_0000

==> s := "abcde".
-: "abcde"

==> realloc(s,3).
-: "abc"

#----------------------------------------------------------
?stack

stack

Builtin data type of ARIBAS.
There are no stack literals. One can generate stacks by variable
declarations. For example, the following top level declaration

    var
        st: stack;
    end.

generates an empty stack. Afterwards, one can put elements
onto the stack using stack_push.

SEE ALSO: stack_push, stack_pop, stack_top, stack_reset, stack_empty
          stack2array
#--------------------------------------------------------------------
?stack_push

stack_push(st: stack; ele: Type): Type;

Puts an element ele (of arbitrary data type Type) on top of the
stack st. The length of the stack is increased by 1. The return
value of the function is ele.

SEE ALSO: stack_arraypush, stack_pop, stack
#-----------------------------------------------------------------
?stack_arraypush

stack_arraypush(st: stack; vec: array of <type> 
                [; direction: integer]): integer;

Pushes the components of the array vec onto the stack
st. If the argument direction is positive or omitted,
the order is from beginning to the end of vec. If
direction is negative, the pushing occurs in reverse order.
Return value is the number of elements pushed on st
(= the length of vec).
Examples:

==> var st: stack; end.
-: var

==> vec := (1,2,3,4,5).
-: (1, 2, 3, 4, 5)

==> stack_arraypush(st,vec,-1).
-: 5

==> vec1 := stack2array(st).
-: (5, 4, 3, 2, 1)

SEE ALSO: stack_push
#-----------------------------------------------------------------
?stack_pop

stack_pop(st: stack): Type;

The stack st must be non-empty. The function removes the top element 
of st and returns it. The length of the stack is decreased by 1.

SEE ALSO: stack_top, stack_push, stack
#-----------------------------------------------------------------
?stack_top

stack_top(st: stack): Type;

Returns the top element of the stack st; the stack itself is
not altered.

SEE ALSO: stack_pop, stack
#-----------------------------------------------------------------
?stack_reset

stack_reset(st: stack): integer;

Removes all elements from the stack st. There remains an empty stack.
The function returns 0.

SEE ALSO: stack_empty, stack
#-----------------------------------------------------------------
?stack_empty

stack_empty(st: stack): boolean;

Tests if the stack st is empty.

SEE ALSO: stack_reset, stack
#-----------------------------------------------------------------
?stack2array

stack2array(st: stack): array of Type;

Returns an array of length equal to length(st) whose components
are the elements lying on the stack. The element at the bottom of 
the stack becomes the component of index 0. After execution of this 
function, the stack st is empty. It is in the responsibility of the 
programmer to ensure that all elements have the correct data type.

SEE ALSO: stack2string, stack_pop, stack
#-----------------------------------------------------------------
?stack2string

stack2string(st: stack): string;

The elements on the stack st, which are strings or characters, 
are concatenated to a string. This string is returned. Elements 
of other data types on the stack are ignored. After execution of 
this function, the stack st is empty. Example:

==> var st: stack; end.
-: var

==> stack_push(st,"stack").
-: "stack"

==> stack_push(st,pi).
-: 3.14159265

==> stack_push(st,'_').
-: '_'

==> stack_push(st,"push").
-: "push"

==> stack2string(st).
-: "stack_push"

SEE ALSO: stack2array, concat
#-----------------------------------------------------------------
?transcript

transcript([fnam: string]): boolean;

Opens a log file with name fnam. The extension .log is appended 
automatically to fnam, if fnam has no extension. If no argument is
given to transcript, "aribas.log" is used by default. For example,

    ==> transcript("a1").
    -: true

opens a file a1.log (if it exists already, its previous content is
lost). The effect of transcript is that all subsequent interaction 
between the user and ARIBAS is transcribed to the log file until the 
log file is closed again with the command

    ==> transcript(0).

The end of an ARIBAS session closes the log file automatically.
#-----------------------------------------------------------------
?help

help(Topic)

Gives a short online help on Topic. For Topic one can use
most symbols of the list returned by the command symbols(aribas).
For example,

    ==> help(factor16).

gives a short description of the builtin function factor16.
Often, the help ends with a list of cross references (introduced
by `SEE ALSO:'). Calling help for the topics listed there gives
you further information. 

SEE ALSO: symbols
#-----------------------------------------------------------------
?length

length(x: array): integer;
length(x: string): integer;
length(x: byte_string): integer;

Returns the length of the array (resp. string, byte_string) x

length(st: stack): integer;

Returns the length of the stack st, i.e. the number of elements
(of arbitrary data type) which lie on the stack.

length(f: file): integer;

f must be a file opened for reading. Then the function returns
the length of the file in bytes.

SEE ALSO: byte_length, bit_length
#--------------------------------------------------------------------
?readln

readln([f: file;] var arg1,...,argn): integer;

Reads a line from file f, which must have been opened for reading. (If the
file argument is not supplied, stdin is assumed, i.e. readln reads from the
terminal.) The arguments arg1,...,argn must be of type integer, real, char or
string. (A string variable consumes all characters until the end of line.)
The return value of readln is the number of successfully read items. If
the end of file is already reached before the call of readln, -1 is returned.
For example, assume that x is an integer variable, c1, c2 are character
variables and s is a string variable. If the current line in the file f is
1234 56 ab
(where the line ends immediately after the character b), then
readln(f,c1,x,c2,s) will return 4 and the variables will contain
the following values:
        c1 = '1', x = 234, c2 = ' ', s = "56 ab".
If the same line is read with readln(f,s,x,c1,c2), then the return
value is 1, the variable s contains the string "1234 56 ab", and
x, c1, c2 are undefined. readln(f) simply returns 0 and advances the
file position to the beginning of the next line.

SEE ALSO: open_read, writeln, read_byte, read_block
#--------------------------------------------------------------------
?write
?writeln

write([f: file;] arg1,...,argn): integer;
writeln([f: file;] arg1,...,argn): integer;

Writes the arguments arg1,...,argn (which may have any data type)
into a text file f, which must have been opened for writing.
The function writeln adds a linefeed to the output.
(If the file argument is not supplied, stdout is assumed, i.e.
the functions write to the terminal.)
Return value is the number of written arguments or -1 in case of error.

SEE ALSO: open_write, open_append, flush
#--------------------------------------------------------------------
?flush

flush([f: file]);

If f is an output file (default f = stdout) to which write operations
have been performed, but some of the data are still being held in a
buffer, then flush writes all data actually to the file.

SEE ALSO: write, write_byte
#--------------------------------------------------------------------
?stdout
?stdin
?stderr

stdout
stdin
stderr

Predefined file variables of ARIBAS, usually (if not redirected)
connected to the terminal. The functions write and writeln, if not
given a file argument, use stdout by default; the function readln,
if not given a file argument, reads from stdin. Error messages
of ARIBAS go to stderr.

SEE ALSO: write, writeln, readln, flush
#--------------------------------------------------------------------
?file

file

Data type in ARIBAS. To access an external file, which is stored 
under a certain name somewhere on the hard disk or a floppy disk
for read or write operations in ARIBAS, it must first be opened 
and assigned to a file variable. This is done with the functions 
open_read, open_append or open_write.

SEE ALSO: open_read, open_append, open_write, readln, writeln,
          binary, read_byte, write_byte
#--------------------------------------------------------------------
?binary

BINARY FILES

In ARIBAS, files are text files by default. However, files can also 
be opened in binary mode for reading and writing using the functions
open_write, open_read, open_append. In this case, a third argument,
consisting of the keyword binary, must be given. Example:

    ==> open_read(f,"BIN.DAT",binary).

This opens a file with name "BIN.DAT", which is supposed to exist,
for reading in binary mode.
For binary files there are the read operations read_byte and
read_block and the write operations write_byte and write_block.
The functions rewind and length may also be applied to binary files,
which have been opened for reading.

SEE ALSO: read_byte, read_block, write_byte, write_block, set_filepos
          open_read, open_write, open_append
#--------------------------------------------------------------------
?set_filepos

set_filepos(f: file; pos: integer): integer;

f must be a binary file, opened for reading and pos must be an integer
satisfying 0 <= pos < length(f). Then set_filepos sets the position
for the next read operation at pos bytes from the beginning of the
file. If pos is not in the admissible range, no action is taken.
Return value is the file position after execution of set_filepos.

SEE ALSO: get_filepos, binary
#--------------------------------------------------------------------
?get_filepos

get_filepos(f: file): integer;

f must be a binary file, opened for reading. The function returns
the current file position.

SEE ALSO: set_filepos, binary
#--------------------------------------------------------------------
?read_byte

read_byte(f: file): integer;

Reads one byte at the current file position from a binary file opened
for reading and increases the file position by 1. Return value is the
read byte (an integer in the range 0 <= x < 256). If the file position
is already end-of-file when read_byte is called, then -1 is returned
and the file position remains unchanged.

SEE ALSO: read_block, write_byte, binary
#--------------------------------------------------------------------
?read_block

read_block(f: file; var block: byte_string; len: integer): integer;

f must be a binary file opened for reading. The argument block must
be a byte_string variable or a subarray of a byte_string with an
actual length >= len. Then read_block reads len bytes from the
file f (starting at the current file position) and stores them
into the first len components of block. If the end-of-file is
reached prematurely, the reading operation is stopped and only the
bytes read so far are stored in block. Return value of read_block
is the number of actually read bytes. The file position is advanced
by this value.

SEE ALSO: read_byte, write_block, binary
#--------------------------------------------------------------------
?write_byte

write_byte(f: file; x: integer): integer:

Writes one byte (given by the integer x in the range 0 <= x < 256) into
a binary file f opened for writing (using open_write or open_append).
Instead of an integer x one can use also a character.
Return value in case of success is the written byte. In case of
error, -1 is returned.

SEE ALSO: write_block, read_byte, binary
#--------------------------------------------------------------------
?write_block

write_block(f: file; var block: byte_string; len: integer): integer;

f must be a binary file opened for writing. The argument block must
be a byte_string variable or a subarray of a byte_string with an
actual length >= len. Then write_block writes the first len bytes
from block into the file f. Return value of write_block is the number
of successfully written bytes. If no error occurs, this number
equals len.

SEE ALSO: write_byte, read_block, binary
#--------------------------------------------------------------------
?open_write

open_write(var f: file; fnam: string): boolean;

Opens a file with name fnam for write operations and sets the
file variable f. (This file variable is needed for the write operations.)
If a file with name fnam does not exist, it is created.
Return value: true if the file has been succesfully opened, and
false, if an error occurs.
In case of success, the variable f is filled with a file descriptor
value that must be used for subsequent write operations to the file.

CAUTION: If a file with name fnam exists already, its previous
content is overwritten and will be lost.

SEE ALSO: write, open_append, binary
#--------------------------------------------------------------------
?open_append

open_append(var f: file; fnam: string): boolean;

Opens a file with name fnam for write operations and sets the
file variable f. (This file variable is needed for the write operations.)
If a file with name fnam does not exist, it is created.
If the file exists already, the previous content is preserved
and the new write operations are at the end of the file.
Return value: true if the file has been succesfully opened, and
false, if an error occurs.
In case of success, the variable f is filled with a file descriptor
value that must be used for subsequent write operations to the file.

SEE ALSO: write, open_write, binary
#--------------------------------------------------------------------
?open_read

open_read(var f: file; fnam: string): boolean;

Opens an existing file with name fnam for sequential reading.
Return value: true if the file has been succesfully opened, and
false, if an error occurs.
In case of success, the variable f is filled with a file descriptor
value that must be used for subsequent read operations from the file.

SEE ALSO: readln, open_write, binary
#--------------------------------------------------------------------
?rewind

rewind(var f: file): boolean;

If f is a file which has been opened for reading and from which
some data have already been read, rewind(f) resets the file position
for the the next read operation to the beginning of the file.
Return value: true if successful, else false.

SEE ALSO: set_filepos
#--------------------------------------------------------------------
?close

close(f: file): boolean;

Closes a file f which has been opened before.

SEE ALSO: open_write, open_append, open_read
#--------------------------------------------------------------------
?load

load(fnam: string): boolean;

fnam must be the name of a text file with ARIBAS source code,
the extension .ari may be omitted. Then load reads this file
and executes all commands and function definitions in the file
as if they had been input directly at the ARIBAS prompt.
Returns true, if the load operation was successful. In case
of error, an error message is written, specifying a line number,
where the error was detected (actually the error might be in some
previous line).

load(fnam,0).

With a second argument 0 the function load works in quiet mode,
the messages to terminal are suppressed.
#--------------------------------------------------------------------
?system

system(command: string): integer;

The string command is handed to the command interpreter (resp. shell)
of the system for execution. Return value is an error code or 0.
For example, under MS-DOS,

    ==> system("dir").

generates a listing of the current directory. Under UNIX, you can use

    ==> system("ls -l").

for the same purpose.
#-----------------------------------------------------------------
?getenv

getenv(name: string): string;

Returns the value of the environment variable name or the empty
string, if this variable is not defined.
Example: Under UNIX,

    ==> getenv("HOME").

returns the name of the home directory of the current user.
#-----------------------------------------------------------------
?set_workdir

set_workdir(path: string): string;

Sets the current working directory to the one given by 
path. This can be either an absolute or a relative
path. Return value is the new path. If the path does not
exist, or ARIBAS is unable to open it, then the
old working directory remains unchanged and the empty
string is returned.
Example:

==> set_workdir("D:\aribas\work").
-: "D:\aribas\work"

(This example supposes that the directory "D:\aribas\work" exists.)

SEE ALSO: get_workdir
#-----------------------------------------------------------------
?get_workdir

get_workdir(): string;

Retrieves the current working directory.

SEE ALSO: set_workdir
#-----------------------------------------------------------------
?exit

exit

The command exit stops ARIBAS and returns to the shell or command
interpreter from where ARIBAS was called.

SEE ALSO: halt
#-----------------------------------------------------------------
?halt

halt([retcode: integer]): integer;

A call to halt causes an immediate stop of the current program
and a return to top level (even if halt occurs in a deeply nested
function call). The return value is the optional argument retcode,
which must be a 16-bit integer (default value 0).
The function halt is mainly used to recover from serious errors.
Note: In contrast to exit, halt does not stop ARIBAS, but returns
to the ARIBAS prompt.

SEE ALSO: exit
#-----------------------------------------------------------------
?memavail

memavail(): integer;

Writes some memory statistics to the screen and returns the free space
(measured in KB) on the ARIBAS heap. Since ARIBAS possesses a garbage
collector using the half space method, the ARIBAS heap is subdivided
into two equal parts. One part is active, memory requirements are
satisfied from this part. The size of the two parts and the space still
available in the active part is reported. If the memory in the active part
is exhausted, the garbage collector is called automatically. The total
number of garbage collections since the beginning of the current
ARIBAS session is also given. The names of user defined functions and
variables are stored by ARIBAS in a symbol table. The space still
available for this purpose is also reported. One can suppress all messages
by calling memavail with the argument 0. Example:

    ==> memavail(0).
    -: 82

SEE ALSO: gc
#-----------------------------------------------------------------
?gc

gc(): integer;

Forces a garbage collection and returns the new amount of free memory
(in KB) on the ARIBAS heap. The function outputs the same messages
as the function memavail.
A quiet version is gc(0). This is useful for example, if one wants
to call some procedure only if a certain minimal amount of memory
is available, as in the following code

    if gc(0) < 64 then
        writeln("not enough memory for procedure foo");
    else
        foo(...);
        ...
    end;

SEE ALSO: memavail
#-----------------------------------------------------------------
?timer

timer(): integer;

Returns the number of milliseconds elapsed since a certain starting
point dependent on the current computer session. (The precision
is system dependent.) This can be used for example to measure the
time needed to execute a certain function. Example:

    ==> t := timer();
        x := isqrt(2*10**2000);
        timer() - t.
    -: 88

In the above example, which was done with the LINUX version of ARIBAS 
on a computer with a 80486 processor, 33MHz, the square root of 2 was 
calculated with a precision of 1000 decimal places in 88 milliseconds.

SEE ALSO: gmtime
#--------------------------------------------------------------------
?gmtime

gmtime(): string;

Returns Greenwich Mean Time as a string in the format "YYYY:MM:DD:hh:mm:ss" 
(year, month, day, hour, minutes, seconds). You can use the function 
string_split to retrieve the components  of this string and use it to 
write your own custumized time function. Example:

==> gmtime().
-: "2003:06:09:08:26:20"

==> tt := string_split(_,":").
-: ("2003", "06", "09", "08", "26", "20")

==> t0 := alloc(array,6);
    for k := 0 to 5 do
        t0[k] := atoi(tt[k]);
    end;
    t0.
-: (2003, 6, 9, 8, 26, 20)

gmtime(0): integer;

If gmtime is called with the argument 0, then it returns the number 
of seconds passed since Jan. 1, 2000, 0:00 h GMT. Example:

==> gmtime(0).
-: 108462687

SEE ALSO: timer
#--------------------------------------------------------------------
?aribas
?user
?symbols

symbols(aribas).

Returns a list of ARIBAS keywords and builtin functions.
The argument aribas has to be given as it stands
(lower case, without quotes).

symbols(user).

Returns a list of currently user defined variables and functions.

SEE ALSO: make_unbound
#------------------------------------------------------------
?make_unbound

make_unbound(Sym): boolean;

Sym must be a user defined symbol denoting a variable, constant
or function. (The command symbols(user) returns a list of those
symbols). make_unbound removes the binding of Sym. This can be 
useful if one wants to recover memory used for variables 
(holding e.g. big integers or long arrays) which are no longer 
needed. Builtin functions cannot be made unbound. Return value is 
true in case of success, false in case of failure.

SEE ALSO: symbols
#------------------------------------------------------------
?version

version(): integer;

Writes the version number and the architecture, for which ARIBAS
was compiled, to the terminal screen. Returns an integer, which is
100*(major version no) + (minor version no). Example:

    ==> version().
    ARIBAS Version 1.01, Sep. 1996 (MS-DOS 386)
    -: 101

With the optional argument 0, the message to the screen is suppressed.
Example:

    ==> version(0).
    -: 101
#------------------------------------------------------------
?var

var

Variable declarations: In ARIBAS, variables may be declared at top level 
or inside function definitions. For example, the following is a top
level declaration of an integer x and an array vec of length 100.

    ==> var
            x: integer;
            vec: array[100];
        end.
    -: var

Inside function definitions, the end of the variable declaration
is marked by the symbol begin which denotes the start of the 
function code.
Note: At top level, variable declarations are not obligatory since
variables can be created by assignments. However inside function
definitions all used variables have to be declared.

SEE ALSO: procedure, const, external, begin
#------------------------------------------------------------
?const

const

Constant declarations: In ARIBAS, constants may be declared at top
level or inside function definitions. For example, the following
is a top level declaration of an integer constant Bound with
value 2**16 and a constant array Weekdays of strings;

    ==> const
            Bound = 2**16;
            Weekdays = ("SU", "MO", "TU", "WE", "TH", "FR", "SA");
        end.
    -: const

Inside function definitions, the end of the constant declaration
is not marked by the symbol end but either by the symbol var (begin
of a variable declaration) or by the symbol begin (start of the 
function code).

SEE ALSO: var
#------------------------------------------------------------
?external

external

In ARIBAS, all global variables which are used inside a function definition, 
have to be declared as external. The external declaration comes first, 
before the constant and variable declaration. As an example, suppose
that there exists a global integer variable Counter. This can be used
in the following way to count how often the function foo is called:

        function foo(vec: array of real): real;
        external
            Counter: integer;
        var
            len: integer;
        begin
            inc(Counter);
            len := length(vec);
            return product(vec)**(1/len);
        end.

SEE ALSO: procedure, function, var
#------------------------------------------------------------
?type

type

The user may define her own types in top level type declarations.
For example, the following type declaration
    ==> type
            vector = array[3] of real;
            item = record
                key: integer;
                name: string;
                data: byte_string;
            end;
        end.
    -: type
defines a type vector denoting an array of 3 reals and a type item 
which denotes a record with 3 fields (of type integer, string and
byte_string respectively). After such a type declaration
(which can occur only at top level), the newly defined types can
be used at top level and inside functions in the same way as the
builtin data types of ARIBAS.

SEE ALSO: record
#------------------------------------------------------------
?record

A record is a structured data type consisting of several components
(called fields) which may have different types. Records can be defined
in (top level) type declarations, for example
    type
        item = record
            key: integer;
            data: byte_string[8];
        end;
    end;
declares a type item which is a record with two fields, named key
and data. After this type declaration a variable declaration
    var
        xx: item;
    end;
creates a record of type item. The fields of this record are then xx.key 
and xx.data. The first is an integer and the latter a byte_string of 
length 8, so that an assignment of the following form is possible:
    xx.data[5] := 127

SEE ALSO: type, pointer
#------------------------------------------------------------
?pointer

pointer to <RecordType>;

The pointer syntax in ARIBAS is as in Modula-2, however only pointers
to records exist. Pointers can be used to construct dynamical data
types. For example, a linked list of strings can be defined using the 
following type declaration.
    type
        list = pointer to item;
        item = record
            name: string;
            next: list;
        end;
    end;
If after this type declaration a pointer variable of type list is defined 
in a variable declaration like
    var LL: list; end;
then LL does not yet point to a record of type item, but is initialized
with the value nil. In order to make LL point to an actual record,
the procedure new has to be used.

SEE ALSO: record, new, nil
#------------------------------------------------------------
?nil

nil

Constant which can be assigned to any pointer variable. In ARIBAS
all pointer variables are initialized with the value nil. To make a 
pointer variable point to an actual record, the procedure new
has to be used.

SEE ALSO: pointer, new
#------------------------------------------------------------
?new

new(var ptr: pointer to <RecordType>): <RecordType>;

If ptr is a variable of type pointer to a certain record type,
then new(ptr) creates a new record of that type and makes ptr
point to this record. For example, after the variable declaration
    var
        ptr: pointer to record x,y,w,h: integer; end;
    end;
ptr has the value nil. Calling
    ==> new(ptr).
    -: &(0, 0, 0, 0)
produces a record with 4 integer fields ptr^.x, ptr^.y, ptr^.w and ptr^.h, 
which can also be used as left hand sides in assignments, for example

    ==> ptr^.x := ptr^.y := 10; ptr^.w := 512; ptr^.h := 360.
    -: 360

    ==> ptr^.
    -: &(10, 10, 512, 360)

SEE ALSO: pointer, record, nil
#------------------------------------------------------------
?function

data type function 

User defined functions and builtin functions (with the exception of 
write, writeln) can be assigned to variables and used as arguments 
of other functions. Example:

    ==> F := (cos,sin,tan).
    -: (cos, sin, tan)

    ==> for i := 0 to length(F)-1 do
            fun := F[i];
            writeln(fun(pi/6));
        end.
    0.866025404
    0.500000000
    0.577350269

function (and it's synonym procedure) is also the keyword introducing
a function definition, see description under procedure.

SEE ALSO: procedure 
#------------------------------------------------------------
?procedure

function, procedure

The keyword function (or it's synonym procedure) introduces a function 
definition, which has the form
        function <identifier>(<formal parameter list>): <result type>;
        <external declaration>
        <constant declaration>
        <variable declaration>
        begin
            <function body>
        end;
The external, constant and variable declarations may also be absent. Example:
        function foo(x,n: integer): integer;
        var i: integer;
        begin
            for i := x+1 to n do
                x := x*i;
            end;
            return x;
        end;
SEE ALSO: external, const, var, begin, return, function
#------------------------------------------------------------
?return

return <retval>;

A return statement can appear in the body of a function definition
(this body is delimited by the symbols begin and end).
<retval> must be an expression evaluating to an object of
data type equal to the result type of the function. If during
a function call the evaluation reaches the return statement,
the value of <retval> is returned immediately as the result
of the function call. In ARIBAS, the result type of a function
may also be a structured type like an array. Example:

    function foo(x: integer): array[3];
    var
        x2: integer;
    begin
        x2 := x*x;
        return (x,x2,x2*x);
    end;

SEE ALSO: procedure, function, begin
#------------------------------------------------------------
?begin
?end

begin
    <statement list>
end;

Inside a function definition the keyword begin indicates the
start of the function body. The function body and at the same time
the function definition ends with the keyword end. Example:

    function fac(n: integer): integer;
    var
        x, i: integer;
    begin
        x := 1;
        for i := 2 to n do
            x := x*i;
        end;
        return x;
    end;

SEE ALSO: procedure, function
#------------------------------------------------------------
?ARGV

ARGV: array of string;

If you call aribas with command line arguments,

    aribas [options] <ari-file> <arg1> ... <argn>

where <ari-file> is a file with ARIBAS source code, then ARIBAS
will load this file and the vector ARGV will contain the elements
<ari-file>, <arg1>, ..., <argn> as strings. Suppose for example
you have a file startup.ari in the current directory and call

    aribas -q startup 4536 eisenstein

then ARGV = ("startup", "4536", "eisenstein"). If you need some
arguments as numbers and not as strings, you can transform them by
atoi (or atof); in our example x := atoi(ARGV[1]) will do it. The
length of the vector ARGV can be determined by length(ARGV).

SEE ALSO: atoi, atof, length
#------------------------------------------------------------
?_
?__
?___

-
--
---

The symbols _, __ and ___ are pseudo variables which contain
the three most recent results. For example,

    ==> 2**10.
    -: 1024

    ==> _**2.
    -: 1048576

    ==> _*__.
    -: 1073741824

    ==> ___*__*_.
    -: 1152_92150_46068_46976
#------------------------------------------------------------
(************************* EOF *****************************)








